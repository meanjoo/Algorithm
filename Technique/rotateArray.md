# N&times;M 배열 회전

## $90\degree$ 시계 방향 회전

```c++
int N, M;
int size = max(N, M);
int arr[size][size], tmp[size][size];

void rotateCW() {
  swap(N, M);
  for(int i=0; i<N; i++){
    for(int j=0; j<M; j++){
      tmp[i][j] = arr[M-1-j][i];
    }
  }
  copy(&tmp[0][0], &tmp[0][0] + size*size, &arr[0][0]); // #include <algorithm>
}
```

### N != M
|1|2|3|4|5||(0,0)|(0,1)|(0,2)|(0,3)|(0,4)|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|6|7|8|9|10||(1,0)|(1,1)|(1,2)|(1,3)|(1,4)|
|11|12|13|14|15||(2,0)|(2,1)|(2,2)|(2,3)|(2,4)|
|16|17|18|19|20||(3,0)|(3,1)|(3,2)|(3,3)|(3,4)|

시계 방향 회전 후 | 기존 배열의 좌표

|16|11|6|1||(3,0)|(2,0)|(1,0)|(0,0)|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|17|12|7|2||(3,1)|(2,1)|(1,1)|(0,1)|
|18|13|8|3||(3,2)|(2,2)|(1,2)|(0,2)|
|19|14|9|4||(3,3)|(2,3)|(1,3)|(0,3)|
|20|15|10|5||(3,4)|(2,4)|(1,4)|(0,4)|

시계 방향 회전 후의 배열 크기는 M&times;N이다.

회전 후의 위치에 따른 기존 배열의 좌표를 보자. 회전 후 위치 ← 기존 배열의 위치  
N=5, M=4  
* 0행  
  (0,0)←(3,0), (0,1)←(2,0), (0,2)←(1,0), (0,3)←(0,0)
* 1행  
  (1,0)←(3,1), (1,1)←(2,1), (1,2)←(1,1), (1,3)←(0,1)  
...  
* 4행  
  (4,0)←(3,4), (4,1)←(2,4), (4,2)←(1,4), (4,3)←(0,4)

`afterRotate[i][j]`의 값은 `beforeRotate[M-1-j][i]`이다. 

### N == M
|1|2|3|4||(0,0)|(0,1)|(0,2)|(0,3)|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|5|6|7|8||(1,0)|(1,1)|(1,2)|(1,3)|
|9|10|11|12||(2,0)|(2,1)|(2,2)|(2,3)|
|13|14|15|16||(3,0)|(3,1)|(3,2)|(3,3)|

시계 방향 회전 후 | 기존 배열의 좌표

|13|9|5|1||(3,0)|(2,0)|(1,0)|(0,0)|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|14|10|6|2||(3,1)|(2,1)|(1,1)|(0,1)|
|15|11|7|3||(3,2)|(2,2)|(1,2)|(0,2)|
|16|12|8|4||(3,3)|(2,3)|(1,3)|(0,3)|

정방 행렬 배열은 회전해도 크기가 N&times;N로 같다.

## $90\degree$ 반시계 방향 회전
만약 시계 방향으로 회전하는 것이 구현되어 있다면, 반시계 방향으로 회전하는 것은 시계 방향으로 3번 회전하는 것과 같다.  
(시계 방향 또한 마찬가지이다. 반시계 방향으로 회전하는 것이 구현되어 있다면, 시계 방향으로 회전하는 것은 반시계 방향으로 3번 회전하는 것과 같다.)

```c++
void rotateCCW() {
  rotateCW();
  rotateCW();
  rotateCW();
}
```

```c++
int N, M;
int size = max(N, M);
int arr[size][size], tmp[size][size];

void rotateCCW() {
  swap(N, M);
  for(int i=0; i<N; i++){
    for(int j=0; j<M; j++){
      tmp[i][j] = arr[j][N-1-i];
    }
  }
  copy(&tmp[0][0], &tmp[0][0] + size*size, &arr[0][0]); // #include <algorithm>
}
```
