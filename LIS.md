**부분 수열**: 어떠한 수열이 주어졌을 때, 그 수열에서 일부 원소를 뽑아내어 새로 만든 수열

**증가하는 부분 수열**: 오름차순을 만족하는 부분 수열

**최장 증가 부분 수열(LIS; Longest Increasing Subsequence)**: 가장 길면서 오름차순을 만족하는 부분 수열

|6|*2*|1|*5*|*7*|4|*8*|3|
|---|---|---|---|---|---|---|---|

위 수열에서 LIS는 [2, 5, 7, 8]이다. 뿐만 아니라 [1, 5, 7, 8]도 LIS이다. 즉 LIS가 반드시 하나로 결정되는 것은 아니다.

LIS를 구하는 알고리즘은 O(n<sup>2</sup>) 시간에 동작하는 알고리즘과 O(n logn) 시간에 동작하는 알고리즘이 있다.

### :blush: O(n<sup>2</sup>) 시간에 동작하는 알고리즘 - LIS의 길이만
LIS의 길이가 얼마인지 구하는 간편한 방법은 dp를 이용하는 것이다.  
1. 수열(arr)의 길이와 같은 길이를 가지는 length 배열을 하나 선언한다. length[k]는 위치 k에서 끝나는 LIS의 길이이다.
2. 수열의 처음부터 끝까지 순회하면서 각 인덱스에 대해 3 ~ 5 과정을 반복한다. 
3. length[i] = 1로 초기화한다.
4. j = 0 to i - 1인 동안 arr[j] < arr[i]인지 체크한다. 즉 현재 위치(=i)보다 이전에 있는 원소(=j)가 현재 원소보다 작은지 체크한다.  
이를 만족해야 LIS가 될 수 있다.
5. 4를 만족한다면 length[i] = length[j] + 1이 될 수 있음을 알 수 있다.  
length[j] + 1의 의미는 j에서 끝나는 최장 증가 부분 수열의 마지막에 arr[i]를 추가하는 것이 최적이라는 것이다.  
따라서 length[i]는 length[i]와 length[j] + 1 중 더 큰 값으로 갱신하면 된다.
6. length 배열에서 가장 큰 값이 LIS의 길이이다.
```
for(int i = 0; i < n; i++) {
  length[i] = 1;
  for(int j = 0; j < i; j++) {
    if(arr[j] < arr[i])
      length[i] = max(length[i], length[j] + 1);
  }
}

int ans = 0;
for(int i = 0; i < n; i++)
  ans = max(ans, length[i]);
```
|*arr*|6|2|1|5|7|4|8|3|
|---|---|---|---|---|---|---|---|---|

|*length*|1|1|1|2|3|2|4|2|
|---|---|---|---|---|---|---|---|---|

이 방법은 간단하지만 시간복잡도가 O(n<sup>2</sup>)이다.  
input 데이터가 10<sup>6</sup>개(백만 개) 정도만 되어도 O(n<sup>2</sup>)의 알고리즘은 10<sup>12</sup>의 시간이 걸려 너무 많은 시간이 소요된다.  
(보통 1억 번(10<sup>8</sup>)의 연산당 1초)  
input 데이터가 10<sup>4</sup>개 이하인 경우에는 LIS의 길이를 간단히 구할 수 있는 O(n<sup>2</sup>) 시간에 동작하는 알고리즘을 사용해도 괜찮지만,  
그 이상의 데이터가 들어오는 경우라면 O(n logn) 시간에 동작하는 알고리즘을 사용해야 한다.

### :blush: O(n logn) 시간에 동작하는 알고리즘 - LIS의 길이만
O(n<sup>2</sup>) 시간에 동작하는 알고리즘을 O(n logn) 시간에 동작하게 만드는 방법은 이전의 원소들을 탐색하는 과정의 시간을 줄여주는 것이다.  
O(n<sup>2</sup>) 시간에 동작하는 알고리즘은 이전의 원소를 탐색하는 데 O(n) 시간이 걸린다.  
O(n logn) 시간에 동작하는 알고리즘은 lower bound를 이용해서 이전의 원소를 탐색하는 데 O(log n) 시간이 걸리게 하는 것이다.

### :blush: O(n logn) 시간에 동작하는 알고리즘 - LIS의 길이와 수열 모두


<br/><br/>
[참고](https://rebro.kr/33)
