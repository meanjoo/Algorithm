**부분 수열**: 어떠한 수열이 주어졌을 때, 그 수열에서 일부 원소를 뽑아내어 새로 만든 수열

**증가하는 부분 수열**: 오름차순을 만족하는 부분 수열

**최장 증가 부분 수열(LIS; Longest Increasing Subsequence)**: 가장 길면서 오름차순을 만족하는 부분 수열

|6|*2*|1|*5*|*7*|4|*8*|3|
|---|---|---|---|---|---|---|---|

위 수열에서 LIS는 [2, 5, 7, 8]이다. 뿐만 아니라 [1, 5, 7, 8]도 LIS이다. 즉 LIS가 반드시 하나로 결정되는 것은 아니다.

LIS를 구하는 알고리즘은 O(n<sup>2</sup>) 시간에 동작하는 알고리즘과 O(n logn) 시간에 동작하는 알고리즘이 있다.  
<br/><br/>
### :blush: O(n<sup>2</sup>) 시간에 동작하는 알고리즘 - LIS의 길이만
LIS의 길이가 얼마인지 구하는 간편한 방법은 dp를 이용하는 것이다.  
1. 수열(arr)의 길이와 같은 길이를 가지는 length 배열을 하나 선언한다. length[k]는 위치 k에서 끝나는 LIS의 길이이다.
2. 수열의 처음부터 끝까지 순회하면서 각 인덱스에 대해 3 ~ 5 과정을 반복한다. 
3. length[i] = 1로 초기화한다.
4. j = 0 to i - 1인 동안 arr[j] < arr[i]인지 체크한다. 즉 현재 위치(=i)보다 이전에 있는 원소(=j)가 현재 원소보다 작은지 체크한다.  
이를 만족해야 LIS가 될 수 있다.
5. 4를 만족한다면 length[i] = length[j] + 1이 될 수 있음을 알 수 있다.  
length[j] + 1의 의미는 j에서 끝나는 최장 증가 부분 수열의 마지막에 arr[i]를 추가하는 것이 최적이라는 것이다.  
따라서 length[i]는 length[i]와 length[j] + 1 중 더 큰 값으로 갱신하면 된다.
6. length 배열에서 가장 큰 값이 LIS의 길이이다.
```
for(int i = 0; i < n; i++) {
  length[i] = 1;
  for(int j = 0; j < i; j++) {
    if(arr[j] < arr[i])
      length[i] = max(length[i], length[j] + 1);
  }
}

int ans = 0;
for(int i = 0; i < n; i++)
  ans = max(ans, length[i]);
```
|*arr*|6|2|1|5|7|4|8|3|
|---|---|---|---|---|---|---|---|---|

|*length*|1|1|1|2|3|2|4|2|
|---|---|---|---|---|---|---|---|---|

이 방법은 간단하지만 시간복잡도가 O(n<sup>2</sup>)이다.  
input 데이터가 10<sup>6</sup>개(백만 개) 정도만 되어도 O(n<sup>2</sup>)의 알고리즘은 10<sup>12</sup>의 시간이 걸려 너무 많은 시간이 소요된다.  
(보통 1억 번(10<sup>8</sup>)의 연산당 1초)  
input 데이터가 10<sup>4</sup>개 이하인 경우에는 LIS의 길이를 간단히 구할 수 있는 O(n<sup>2</sup>) 시간에 동작하는 알고리즘을 사용해도 괜찮지만,  
그 이상의 데이터가 들어오는 경우라면 O(n logn) 시간에 동작하는 알고리즘을 사용해야 한다.  
<br/><br/>
### :blush: O(n logn) 시간에 동작하는 알고리즘 - LIS의 길이만
O(n<sup>2</sup>) 시간에 동작하는 알고리즘을 O(n logn) 시간에 동작하게 만드는 방법은 이전의 원소들을 탐색하는 과정의 시간을 줄여주는 것이다.  
O(n<sup>2</sup>) 시간에 동작하는 알고리즘은 이전의 원소를 탐색하는 데 O(n) 시간이 걸린다.  
O(n logn) 시간에 동작하는 알고리즘은 lower bound를 이용해서 이전의 원소를 탐색하는 데 O(log n) 시간이 걸리게 하는 것이다.  

:star2: 핵심 아이디어는 LIS를 만드는 과정에서 **LIS의 마지막 원소가 가능한 작을수록 더 긴 LIS를 생성할 수 있다**는 것이다.  
따라서 들어오는 값이 현재 생성된 LIS의 마지막 원소보다 작은 경우에 LIS에 들어갈 자리를 O(logn) 시간에 찾아서 값을 대체한다.

간단한 예시로 수열 [1, 2, 3, 7, 5, 6]에서 5까지 탐색했을 때의 가능한 LIS는 [1, 2, 3, 7]과 [1, 2, 3, 5]이다.  
우리는 LIS의 길이만 알면 되기 때문에 둘 다 LIS를 만족하는데, 더 긴 LIS를 만들기 위해서는 [1, 2, 3, 5]가 [1, 2, 3, 7]보다 더 적합하다.  
실제로 마지막 원소인 6이 들어올 때 [1, 2, 3, 7]로는 더 긴 LIS를 생성할 수 없지만,  
[1, 2, 3, 5]로는 뒤에 6을 붙여 더 긴 LIS [1, 2, 3, 5, 6]을 만들 수 있다.

이러한 원리로 차례대로 원소가 들어올 때, 다음과 같은 과정을 거친다.  
**들어오는 원소가 이전 범위까지의 LIS의 마지막 원소보다 더 크면 바로 뒤에 붙여주고, 작으면 LIS에 들어갈 자리를 찾아서 값을 대체한다.**  
LIS의 길이를 구하기 위해서는 LIS를 만족하는 수열을 담기 위한 배열/벡터가 따로 필요하다.  
(배열로 선언한다면 arr과 같은 길이를 가지도록 선언하고, 현재 인덱스를 가리키는 변수도 함께 선언한다.)

위에서 예로 들었던 수열 [1, 2, 3, 7, 5, 6]의 단계별 동작 과정을 보자. 따로 만든 배열/벡터를 lis라고 하자.  
(0) lis = [ ]
(1) lis = [1] ← 처음에는 빈 배열이기 때문에 값을 바로 넣어준다.  
(2) lis = [1, 2] ← 2>1; 들어오는 2가 이전까지의 lis의 마지막 원소인 1보다 크므로 바로 뒤에 붙여준다.  
(3) lis = [1, 2, 3] ← 3>2  
(4) lis = [1, 2, 3, 7] ← 7>3  
(5) lis = [1, 2, 3, 5] ← 5<7; 들어오는 5가 이전까지의 lis의 마지막 원소인 7보다 작다. 이전까지의 lis에서 lower_bound(5)가 3이기 때문에 lis[3] = 5가 된다.  
(6) lis = [1, 2, 3, 5, 6] ← 6>5  
LIS는 [1, 2, 3, 5, 6]이고, 길이는 5이다.

다른 예로 수열 [10, 20, 10, 30, 25, 50]을 보자.  
(0) lis = [ ]
(1) lis = [10] ← empty; 10 추가  
(2) lis = [10, 20] ← 20>10; 20 추가  
(3) lis = [10, 20] ← 10<20; 0번 10이 10으로 대체  
(4) lis = [10, 20, 30] ← 30>20; 30 추가  
(5) lis = [10, 20, 25] ← 25<30; 2번 30이 25로 대체  
(6) lis = [10, 20, 25, 50] ← 50>25; 50 추가  

:boom: 이처럼 위의 알고리즘이 lis 배열에 항상 LIS를 만드는 것 같지만 실제로 **이 알고리즘으로는 LIS의 길이만 구할 수 있다.**

수열 [3, 5, 2, 6, 1]을 보자.  
(0) lis = [ ]
(1) lis = [3]  
(2) lis = [3, 5]  
(3) lis = [2, 5]  
(4) lis = [2, 5, 6]  
(5) lis = [1, 5, 6]  
위 수열의 실제 LIS는 [3, 5, 6]이지만 이 알고리즘을 통해 만들어진 LIS는 [1, 5, 6]이다.  
[1, 5, 6]은 [3, 5, 2, 6, 1]에서 만들어질 수 없는 부분 수열이지만, 단순히 LIS의 길이만 구하는 것이 목적이라면 답에 영향을 주지는 않는다.

위 수열을 끝까지 탐색했을 때 LIS의 길이는 3이다.  
만약 6보다 더 큰 수가 들어온다면 [1, 5, 6] 뒤에 붙게 되는데, 이는 결국 [3, 5, 6] 뒤에 붙는 것과 길이 측면에서는 차이가 없다.  
만약 6보다 작은 수가 들어온다면 [1, 5, 6]에든 [3, 5, 6]에든 추가로 뒤에 더 붙을 수는 없고,  
[1, 5, 6]에서나 [3, 5, 6]에서나 단순히 교체만 될 것이기 때문에 LIS의 길이는 3으로 유지된다.

이러한 이유로 이 알고리즘으로는 LIS의 길이는 구할 수 있지만,  
실제 LIS를 이루는 부분 수열이 무엇인지 알기 위해서는 추가적인 작업이 필요하다.

:black_medium_square: lis를 arr과 같은 길이의 배열로 선언한 경우  
아래 코드는 arr 배열을 만들고 lis를 구성하는 것인데,  
if (idx == 0) 위에 arr[i]를 하나씩 num으로 받으면 arr[i]를 num으로 변경하여 arr을 만들지 않고도 lis를 구성할 수 있다.
```
int lenLIS() {
  int idx = 0;
  for (int i = 0; i < n; i++) {
    // int num; cin >> num; 
    if (idx == 0)
      lis[idx++] = arr[i];
    else {
      if (arr[i] > lis[idx - 1])
        lis[idx++] = arr[i];
      else
        lis[lower_bound(lis, lis + idx, arr[i]) - lis] = arr[i];
        // lower_bound(lis, lis + idx, arr[i]) = arr[i];는 안 되나? 해보기
    }    
  }
  return idx;
}
```
*lis를 vector로 선언한 경우*  
```
int lenLIS() {
  for (int i = 0; i < n; i++) {
    if (lis.empty())
      lis.push_back(arr[i]);
    else {
      int sz = lis.size();
      if (arr[i] > lis[sz - 1])
        lis.push_back(arr[i]);
      else
        lis[lower_bound(lis.begin(), lis.end(), arr[i]) - lis.begin()] = arr[i];
    }
  }
  return (int)lis.size();
}
```
<br/><br/>
### :blush: O(n logn) 시간에 동작하는 알고리즘 - LIS의 길이와 수열 모두


<br/><br/>
<br/><br/>
[참고](https://rebro.kr/33)
